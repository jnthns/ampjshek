(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Experiment = {}));
}(this, (function (exports) { 'use strict';

    /**
     * Determines the primary source of variants before falling back.
     *
     * @category Configuration
     */
    (function (Source) {
        /**
         * The default way to source variants within your application. Before the
         * assignments are fetched, `getVariant(s)` will fallback to local storage
         * first, then `initialVariants` if local storage is empty. This option
         * effectively falls back to an assignment fetched previously.
         */
        Source["LocalStorage"] = "localStorage";
        /**
         * This bootstrap option is used primarily for servers-side rendering using an
         * Experiment server SDK. This bootstrap option always prefers the config
         * `initialVariants` over data in local storage, even if variants are fetched
         * successfully and stored locally.
         */
        Source["InitialVariants"] = "initialVariants";
    })(exports.Source || (exports.Source = {}));
    /**
     Defaults for Experiment Config options

     | **Option**       | **Default**                       |
     |------------------|-----------------------------------|
     | **debug**        | `false`                           |
     | **fallbackVariant**         | `null`                 |
     | **initialVariants**         | `null`                 |
     | **source** | `Source.LocalStorage` |
     | **serverUrl**    | `"https://api.lab.amplitude.com"` |
     | **assignmentTimeoutMillis**    | `10000` |
     | **retryFailedAssignment**    | `true` |

     *
     * @category Configuration
     */
    var Defaults = {
        debug: false,
        fallbackVariant: {},
        initialVariants: {},
        source: exports.Source.LocalStorage,
        serverUrl: 'https://api.lab.amplitude.com',
        fetchTimeoutMillis: 10000,
        retryFetchOnFailure: true,
    };

    /**
     * An AmplitudeUserProvider injects information from the Amplitude SDK into
     * the {@link ExperimentUser} object before sending a request to the server.
     * @category Context Provider
     */
    var AmplitudeUserProvider = /** @class */ (function () {
        function AmplitudeUserProvider(amplitudeInstance) {
            this.amplitudeInstance = amplitudeInstance;
        }
        AmplitudeUserProvider.prototype.getUser = function () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            return {
                device_id: (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.deviceId,
                user_id: (_d = (_c = this.amplitudeInstance) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.userId,
                version: (_f = (_e = this.amplitudeInstance) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.versionName,
                language: (_h = (_g = this.amplitudeInstance) === null || _g === void 0 ? void 0 : _g.options) === null || _h === void 0 ? void 0 : _h.language,
                platform: (_k = (_j = this.amplitudeInstance) === null || _j === void 0 ? void 0 : _j.options) === null || _k === void 0 ? void 0 : _k.platform,
                os: this.getOs(),
                device_model: this.getDeviceModel(),
            };
        };
        AmplitudeUserProvider.prototype.getOs = function () {
            var _a, _b, _c, _d, _e, _f;
            return [
                (_c = (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a._ua) === null || _b === void 0 ? void 0 : _b.browser) === null || _c === void 0 ? void 0 : _c.name,
                (_f = (_e = (_d = this.amplitudeInstance) === null || _d === void 0 ? void 0 : _d._ua) === null || _e === void 0 ? void 0 : _e.browser) === null || _f === void 0 ? void 0 : _f.major,
            ]
                .filter(function (e) { return e !== null && e !== undefined; })
                .join(' ');
        };
        AmplitudeUserProvider.prototype.getDeviceModel = function () {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a._ua) === null || _b === void 0 ? void 0 : _b.os) === null || _c === void 0 ? void 0 : _c.name;
        };
        return AmplitudeUserProvider;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }
    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

      return r;
    }

    var version = "1.0.3";

    /**
     * @packageDocumentation
     * @internal
     */
    var LocalStorage = /** @class */ (function () {
        function LocalStorage(instanceName, apiKey) {
            this.map = {};
            var shortApiKey = apiKey.substring(apiKey.length - 6);
            this.namespace = "amp-exp-" + instanceName + "-" + shortApiKey;
        }
        LocalStorage.prototype.put = function (key, value) {
            this.map[key] = value;
        };
        LocalStorage.prototype.get = function (key) {
            var value = this.map[key];
            if (value === undefined) {
                value = null;
            }
            return value;
        };
        LocalStorage.prototype.clear = function () {
            this.map = {};
        };
        LocalStorage.prototype.getAll = function () {
            return this.map;
        };
        LocalStorage.prototype.load = function () {
            try {
                var map = JSON.parse(localStorage.getItem(this.namespace)) || {};
                var newMap = {};
                for (var _i = 0, _a = Object.entries(map); _i < _a.length; _i++) {
                    var _b = _a[_i], key = _b[0], value = _b[1];
                    if (typeof value === 'string') {
                        // old format
                        newMap[key] = { value: value };
                    }
                    else if (typeof value === 'object') {
                        // new format
                        newMap[key] = {
                            value: value['value'],
                            payload: value['payload'],
                        };
                    }
                }
                this.map = newMap;
            }
            catch (e) {
                this.map = {};
            }
        };
        LocalStorage.prototype.save = function () {
            try {
                localStorage.setItem(this.namespace, JSON.stringify(this.map));
            }
            catch (e) {
                // pass
            }
        };
        return LocalStorage;
    }());

    function unfetch (e, n) {
      return n = n || {}, new Promise(function (t, r) {
        var s = new XMLHttpRequest(),
            o = [],
            u = [],
            i = {},
            a = function () {
          return {
            ok: 2 == (s.status / 100 | 0),
            statusText: s.statusText,
            status: s.status,
            url: s.responseURL,
            text: function () {
              return Promise.resolve(s.responseText);
            },
            json: function () {
              return Promise.resolve(JSON.parse(s.responseText));
            },
            blob: function () {
              return Promise.resolve(new Blob([s.response]));
            },
            clone: a,
            headers: {
              keys: function () {
                return o;
              },
              entries: function () {
                return u;
              },
              get: function (e) {
                return i[e.toLowerCase()];
              },
              has: function (e) {
                return e.toLowerCase() in i;
              }
            }
          };
        };

        for (var l in s.open(n.method || "get", e, !0), s.onload = function () {
          s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function (e, n, t) {
            o.push(n = n.toLowerCase()), u.push([n, t]), i[n] = i[n] ? i[n] + "," + t : t;
          }), t(a());
        }, s.onerror = r, s.withCredentials = "include" == n.credentials, n.headers) s.setRequestHeader(l, n.headers[l]);

        s.send(n.body || null);
      });
    }

    var safeGlobal = typeof globalThis !== 'undefined' ? globalThis : global || self;

    /**
     * @packageDocumentation
     * @internal
     */
    var fetch = safeGlobal.fetch || unfetch;
    /*
     * Copied from:
     * https://github.com/github/fetch/issues/175#issuecomment-284787564
     */
    var timeout = function (promise, timeoutMillis) {
        // Dont timeout if timeout is null or invalid
        if (timeoutMillis == null || timeoutMillis <= 0) {
            return promise;
        }
        return new Promise(function (resolve, reject) {
            safeGlobal.setTimeout(function () {
                reject(Error('Request timeout after ' + timeoutMillis + ' milliseconds'));
            }, timeoutMillis);
            promise.then(resolve, reject);
        });
    };
    var request = function (requestUrl, method, headers, data, timeoutMillis) {
        return timeout(fetch(requestUrl, {
            method: method,
            headers: headers,
            body: data,
        }), timeoutMillis);
    };
    var FetchHttpClient = { request: request };

    var Backoff = /** @class */ (function () {
        function Backoff(attempts, min, max, scalar) {
            this.started = false;
            this.done = false;
            this.attempts = attempts;
            this.min = min;
            this.max = max;
            this.scalar = scalar;
        }
        Backoff.prototype.start = function (fn) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.started) {
                                this.started = true;
                            }
                            else {
                                throw Error('Backoff already started');
                            }
                            return [4 /*yield*/, this.backoff(fn, 0, this.min)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        Backoff.prototype.cancel = function () {
            this.done = true;
            clearTimeout(this.timeoutHandle);
        };
        Backoff.prototype.backoff = function (fn, attempt, delay) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    if (this.done) {
                        return [2 /*return*/];
                    }
                    this.timeoutHandle = safeGlobal.setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                        var e_1, nextAttempt, nextDelay;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, fn()];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 3];
                                case 2:
                                    e_1 = _a.sent();
                                    nextAttempt = attempt + 1;
                                    if (nextAttempt < this.attempts) {
                                        nextDelay = Math.min(delay * this.scalar, this.max);
                                        this.backoff(fn, nextAttempt, nextDelay);
                                    }
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); }, delay);
                    return [2 /*return*/];
                });
            });
        };
        return Backoff;
    }());

    var CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var randomString = function (length, alphabet) {
        if (alphabet === void 0) { alphabet = CHARS; }
        var str = '';
        for (var i = 0; i < length; ++i) {
            str += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }
        return str;
    };

    /**
     * @packageDocumentation
     * @module experiment-js-client
     */
    // Configs which have been removed from the public API.
    // May be added back in the future.
    var fetchBackoffTimeout = 10000;
    var fetchBackoffAttempts = 8;
    var fetchBackoffMinMillis = 500;
    var fetchBackoffMaxMillis = 10000;
    var fetchBackoffScalar = 1.5;
    // TODO this is defined twice, figure something better out.
    var defaultInstance = '$default_instance';
    /**
     * The default {@link Client} used to fetch variations from Experiment's
     * servers.
     *
     * @category Core Usage
     */
    var ExperimentClient = /** @class */ (function () {
        /**
         * Creates a new ExperimentClient instance.
         *
         * In most cases you will want to use the `initialize` factory method in
         * {@link Experiment}.
         *
         * @param apiKey The Client key for the Experiment project
         * @param config See {@link ExperimentConfig} for config options
         */
        function ExperimentClient(apiKey, config) {
            this.user = null;
            this.userProvider = null;
            this.apiKey = apiKey;
            this.config = __assign(__assign({}, Defaults), config);
            this.httpClient = FetchHttpClient;
            this.storage = new LocalStorage(defaultInstance, apiKey);
            this.storage.load();
        }
        /**
         * Assign the given user to the SDK and asynchronously fetch all variants
         * from the server. Subsequent calls may omit the user from the argument to
         * use the user from the previous call.
         *
         * If an {@link ExperimentUserProvider} has been set, the argument user will
         * be merged with the provider user, preferring user fields from the argument
         * user and falling back on the provider for fields which are null or
         * undefined.
         *
         * If configured, fetch retries the request in the background on failure.
         * Variants received from a successful retry are stored in local storage for
         * access.
         *
         * If you are using the `initialVariants` config option to pre-load this SDK
         * from the server, you generally do not need to call `fetch`.
         *
         * @param user The user to fetch variants for.
         * @returns Promise that resolves when the request for variants completes.
         * @see ExperimentUser
         * @see ExperimentUserProvider
         */
        ExperimentClient.prototype.fetch = function (user) {
            if (user === void 0) { user = this.user; }
            return __awaiter(this, void 0, void 0, function () {
                var e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.setUser(user || {});
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.fetchInternal(user, this.config.fetchTimeoutMillis, this.config.retryFetchOnFailure)];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            console.error(e_1);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/, this];
                    }
                });
            });
        };
        /**
         * Returns the variant for the provided key.
         *
         * Fetches {@link all} variants, falling back  on the given fallback, then the
         * configured fallbackVariant.
         *
         * @param key The key to get the variant for.
         * @param fallback The highest priority fallback.
         * @see ExperimentConfig
         */
        ExperimentClient.prototype.variant = function (key, fallback) {
            var _a, _b, _c;
            if (!this.apiKey) {
                return { value: undefined };
            }
            var variant = (_c = (_b = (_a = this.sourceVariants()[key]) !== null && _a !== void 0 ? _a : fallback) !== null && _b !== void 0 ? _b : this.secondaryVariants()[key]) !== null && _c !== void 0 ? _c : this.config.fallbackVariant;
            var converted = this.convertVariant(variant);
            this.debug("[Experiment] variant for " + key + " is " + converted.value);
            return converted;
        };
        /**
         * Returns all variants for the user.
         *
         * The primary source of variants is based on the
         * {@link Source} configured in the {@link ExperimentConfig}.
         *
         * @see Source
         * @see ExperimentConfig
         */
        ExperimentClient.prototype.all = function () {
            if (!this.apiKey) {
                return {};
            }
            return __assign(__assign({}, this.secondaryVariants()), this.sourceVariants());
        };
        /**
         * Get a copy of the internal {@link ExperimentUser} object if it is set.
         *
         * @returns a copy of the internal user object if set.
         */
        ExperimentClient.prototype.getUser = function () {
            if (!this.user) {
                return this.user;
            }
            var userPropertiesCopy = __assign({}, this.user.user_properties);
            return __assign(__assign({}, this.user), { user_properties: userPropertiesCopy });
        };
        /**
         * Copy in and set the user within the experiment client.
         *
         * @param user the user to set within the experiment client.
         */
        ExperimentClient.prototype.setUser = function (user) {
            if (!user) {
                this.user = null;
                return;
            }
            var userPropertiesCopy = __assign({}, user.user_properties);
            this.user = __assign(__assign({}, user), { user_properties: userPropertiesCopy });
        };
        /**
         * Get the user provider set by {@link setUserProvider} or null if the user
         * provider has not been set.
         *
         * @returns The user provider set by {@link setUserProvider} or null.
         */
        ExperimentClient.prototype.getUserProvider = function () {
            return this.userProvider;
        };
        /**
         * Sets a user provider that will inject identity information into the user
         * for {@link fetch()} requests. The user provider will only set user fields
         * in outgoing requests which are null or undefined.
         *
         * See {@link ExperimentUserProvider} for more details
         * @param userProvider
         */
        ExperimentClient.prototype.setUserProvider = function (userProvider) {
            this.userProvider = userProvider;
            return this;
        };
        ExperimentClient.prototype.fetchInternal = function (user, timeoutMillis, retry) {
            return __awaiter(this, void 0, void 0, function () {
                var variants, e_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // Don't even try to fetch variants if API key is not set
                            if (!this.apiKey) {
                                throw Error('Experiment API key is empty');
                            }
                            this.debug("[Experiment] Fetch all: retry=" + retry);
                            // Proactively cancel retries if active in order to avoid unecessary API
                            // requests. A new failure will restart the retries.
                            if (retry) {
                                this.stopRetries();
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.doFetch(user, timeoutMillis)];
                        case 2:
                            variants = _a.sent();
                            this.storeVariants(variants);
                            return [2 /*return*/, variants];
                        case 3:
                            e_2 = _a.sent();
                            if (retry) {
                                this.startRetries(user);
                            }
                            throw e_2;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        ExperimentClient.prototype.doFetch = function (user, timeoutMillis) {
            return __awaiter(this, void 0, void 0, function () {
                var userContext, queryString, endpoint, headers, body, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            userContext = this.addContext(user);
                            queryString = '';
                            if (this.config.debug) {
                                queryString = "?d=" + randomString(8);
                            }
                            endpoint = this.config.serverUrl + "/sdk/vardata" + queryString;
                            headers = {
                                Authorization: "Api-Key " + this.apiKey,
                            };
                            body = JSON.stringify(userContext);
                            // CDN can only cache requests where the body is < 8KB
                            if (body.length > 8000) {
                                console.warn("[Experiment] encoded user object length " + body.length + " cannot be cached by CDN; must be < 8KB");
                            }
                            this.debug('[Experiment] Fetch variants for user: ', userContext);
                            return [4 /*yield*/, this.httpClient.request(endpoint, 'POST', headers, body, timeoutMillis)];
                        case 1:
                            response = _a.sent();
                            if (response.status != 200) {
                                throw Error("Fetch error response: status=" + response.status);
                            }
                            this.debug('[Experiment] Received fetch response: ', response);
                            return [4 /*yield*/, this.parseResponse(response)];
                        case 2: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        ExperimentClient.prototype.parseResponse = function (response) {
            return __awaiter(this, void 0, void 0, function () {
                var json, variants, _i, _a, key;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, response.json()];
                        case 1:
                            json = _b.sent();
                            variants = {};
                            for (_i = 0, _a = Object.keys(json); _i < _a.length; _i++) {
                                key = _a[_i];
                                variants[key] = {
                                    value: json[key].key,
                                    payload: json[key].payload,
                                };
                            }
                            this.debug('[Experiment] Received variants: ', variants);
                            return [2 /*return*/, variants];
                    }
                });
            });
        };
        ExperimentClient.prototype.storeVariants = function (variants) {
            this.storage.clear();
            for (var key in variants) {
                this.storage.put(key, variants[key]);
            }
            this.storage.save();
            this.debug('[Experiment] Stored variants: ', variants);
        };
        ExperimentClient.prototype.startRetries = function (user) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    this.debug('[Experiment] Retry fetch');
                    this.retriesBackoff = new Backoff(fetchBackoffAttempts, fetchBackoffMinMillis, fetchBackoffMaxMillis, fetchBackoffScalar);
                    this.retriesBackoff.start(function () { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.fetchInternal(user, fetchBackoffTimeout, false)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    return [2 /*return*/];
                });
            });
        };
        ExperimentClient.prototype.stopRetries = function () {
            if (this.retriesBackoff != null) {
                this.retriesBackoff.cancel();
            }
        };
        ExperimentClient.prototype.addContext = function (user) {
            var _a;
            return __assign(__assign({ library: "experiment-js-client/" + version }, (_a = this.userProvider) === null || _a === void 0 ? void 0 : _a.getUser()), user);
        };
        ExperimentClient.prototype.convertVariant = function (value) {
            if (value === null || value === undefined) {
                return {};
            }
            if (typeof value == 'string') {
                return {
                    value: value,
                };
            }
            else {
                return value;
            }
        };
        ExperimentClient.prototype.sourceVariants = function () {
            if (this.config.source == exports.Source.LocalStorage) {
                return this.storage.getAll();
            }
            else if (this.config == exports.Source.InitialVariants) {
                return this.config.initialVariants;
            }
        };
        ExperimentClient.prototype.secondaryVariants = function () {
            if (this.config.source == exports.Source.LocalStorage) {
                return this.config.initialVariants;
            }
            else if (this.config == exports.Source.InitialVariants) {
                return this.storage.getAll();
            }
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ExperimentClient.prototype.debug = function (message) {
            var optionalParams = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                optionalParams[_i - 1] = arguments[_i];
            }
            if (this.config.debug) {
                console.debug.apply(console, __spreadArrays([message], optionalParams));
            }
        };
        return ExperimentClient;
    }());

    var instances = {};
    // TODO this is defined twice, figure something better out.
    var defaultInstance$1 = '$default_instance';
    /**
     * Initializes a singleton {@link ExperimentClient} identified by the api-key.
     *
     * @param apiKey The environment API Key
     * @param config See {@link ExperimentConfig} for config options
     */
    var initialize = function (apiKey, config) {
        if (!instances[defaultInstance$1]) {
            instances[defaultInstance$1] = new ExperimentClient(apiKey, config);
        }
        return instances[defaultInstance$1];
    };
    /**
     * Provides factory methods for storing singleton instances of {@link ExperimentClient}
     * @category Core Usage
     */
    var Experiment = {
        initialize: initialize,
    };

    /**
     * A stub {@link Client} implementation that does nothing for all methods
     */
    var StubExperimentClient = /** @class */ (function () {
        function StubExperimentClient() {
        }
        StubExperimentClient.prototype.getUser = function () {
            return {};
        };
        StubExperimentClient.prototype.setUser = function (user) { };
        StubExperimentClient.prototype.fetch = function (user) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this];
                });
            });
        };
        StubExperimentClient.prototype.getUserProvider = function () {
            return null;
        };
        StubExperimentClient.prototype.setUserProvider = function (uerProvider) {
            return this;
        };
        StubExperimentClient.prototype.variant = function (key, fallback) {
            return Defaults.fallbackVariant;
        };
        StubExperimentClient.prototype.all = function () {
            return {};
        };
        return StubExperimentClient;
    }());

    exports.AmplitudeUserProvider = AmplitudeUserProvider;
    exports.Experiment = Experiment;
    exports.ExperimentClient = ExperimentClient;
    exports.StubExperimentClient = StubExperimentClient;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
